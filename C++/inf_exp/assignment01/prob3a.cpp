#include <iostream>
using namespace std;

// Assignment 3a

int main()
{
  int a = 1;
  int* b = &a;   // ポインタオブジェクトbはaのアドレスを保持
  int** c = &b;  // cはポインタオブジェクトbのアドレスを保持するint型へのポインタのポインタ
  int* const * d = c;  // dはポインタオブジェクトcのアドレスを保持する
                       // (cの内容をコピーして代入)するので保持している中身は同じだが、新しくconstを書く。
                       // ここでconstは(右から数えて2個目のポインタ)を修飾しているので、
                       // (右から数えて)1個目のポインタ(dが保持するcのアドレス)は変更可
                       // (OK: d = &i (新しいアドレス))
                       // (右から数えて)2個目のポインタはconst修飾 (NG: *d = &i (新しいアドレス)
  const int * const * e = d;  // 変数dのコピー(中身の書き換えはしていないので変数cと同じ内容)
                              // 上行同様の2個目のポインタをconstにし、かつ、
                              // ポインタのポインタが(3つ先)指し示すint型の値も不偏
                              // (NG: **e = 2)
  int const * const * f = e; // 上の行と同義の新しい変数fの宣言なのでエラーなし
                             // 一番左側の時だけconstは右側を修飾というルールの確認問題
  int const * * const g = f;  // エラー
                               // (右から数えて)2個目のポインタが書き換え可能な変数なので、
                               // そうでないfの代入はエラー
                               // 1個目のポインタ(gのアドレス)をconst修飾には問題はない。


  // cout << "ポインタへのポインタの中身確認";
  // cout << "c = " << c << " d = " <<  d << " *c = " << *c << " *d = " << *d << " " << endl;
  // cout << "**c = " << **c << " **d = " << **d << endl;


  //int z = 3;
  //b = &z;
  cout << " &b = " << &b << " c = " << c << " *c = " << *c << " &a " << &a << endl;

  cout << "ポインタオブジェクトのポインタdの中身 d = " << d << endl;
  cout << "*dはdの保持するアドレスへのアクセス(今はiのアドレスにア) *d = " << *d << endl;

  int h = 3;
  int* i = &h;
  //*d = i;  // エラー
  cout << "\nポインタオブジェクトiのアドレス &i = " << &i << endl;
  cout << "ポインタオブジェクトのポインタdが保持しているもの d = " << d << endl;

  cout << "*dはdの保持するアドレスへのアクセス(今はiのアドレスにア) *d = " << *d << endl;

  return 0;
}

